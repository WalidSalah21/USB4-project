//% this code generated by Ai "github cobilot" ^-^

// This class represents an upper layer driver
class up_transport_driver;

    // Interface to the upper layer
    virtual upper_layer_if vif;

    // Transaction object for the upper layer
    upper_layer_tr tr;

    // Mailbox for communication between monitor and scoreboard
    mailbox #(upper_layer_tr) drv_gen_mbx;

    // Event to signal when driving is done
    event driveDone;

    // Constructor
    function new(virtual upper_layer_if vif, mailbox #(upper_layer_tr) drv_gen_mbx, event doneEvent);
        this.vif = vif;
        this.drv_gen_mbx = drv_gen_mbx;
        this.driveDone = doneEvent;
    endfunction


    task run(input GEN speed);

        while (vif.enable_sending == 1) begin
            
         // Get the transaction from the mailbox
        drv_gen_mbx.get(tr);

        // Wait for 4 clock cycles
        repeat(4) wait_for_negedge(speed);
      
        // Assign T_Data to transport_layer_data_in
        vif.transport_layer_data_in = tr.T_Data;
      
        // Wait for 4 more clock cycles
        repeat(4) wait_for_negedge(speed);
      
        // Assign T_Data_1 to transport_layer_data_in
        vif.transport_layer_data_in = tr.T_Data_1;
        
        wait_for_negedge(speed);
      
        ->driveDone;
  
    end
  
        
    endtask








  task wait_for_negedge( input GEN gen_speed );
  case (gen_speed)
  gen2: @(negedge  vif.gen2_fsm_clk );
  gen3: @(negedge  vif.gen3_fsm_clk);
  gen4: @(negedge  vif.gen4_fsm_clk);
  default: @(negedge  vif.gen4_fsm_clk );
  endcase
  endtask

    
endclass